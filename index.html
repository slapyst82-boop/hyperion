<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hyperion Client</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
        color: white;
        text-shadow: 0 0 15px rgba(255,255,255,0.7);
    }
    canvas {
        position: fixed;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }
    .center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
    }
    h1 {
        font-size: 64px;
        margin-bottom: 20px;
    }
    .subtext {
        font-size: 20px;
        margin-top: -10px;
        opacity: 0.8;
    }
    .btn {
        display: inline-block;
        padding: 15px 30px;
        margin: 10px;
        font-size: 18px;
        color: white;
        background-color: rgba(0,0,0,0.6);
        border: none;
        border-radius: 8px;
        cursor: pointer;
        text-decoration: none;
        transition: background 0.3s ease;
    }
    .btn:hover {
        background-color: rgba(255,255,255,0.2);
    }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<div class="center">
    <h1>Hyperion</h1>
    <p class="subtext">Client made by @zxlightning1 and @ModdinMC</p>
    <a href="https://discord.gg/wvm97yzBkt" class="btn">Download</a>
    <a href="https://discord.gg/wvm97yzBkt" class="btn">Join Discord</a>
</div>

<script id="fragShader" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 resolution;

#define R_FACTOR 5.
#define G_FACTOR 0.
#define B_FACTOR 0.

const int MAXITER = 42;

vec3 field(vec3 p) {
    p *= .1;
    float f = .1;
    for (int i = 0; i < 5; i++) {
        p = p.yzx*mat3(.8,.6,0,-.6,.8,0,0,0,1);
        p += vec3(.623,.656,.689)*float(i);
        p = abs(fract(p)-.5);
        p *= 2.0;
        f *= 2.0;
    }
    p *= p;
    return sqrt(p+p.yzx)/f-.002;
}

void main( void ) {
    vec3 dir = normalize(vec3((gl_FragCoord.xy-resolution*.5)/resolution.x,1.));
    vec3 pos = vec3(.4, .5,time);
    vec3 color = vec3(0);
    for (int i = 0; i < MAXITER; i++) {
        vec3 f2 = field(pos);
        float f = min(min(f2.x,f2.y),f2.z);
        pos += dir*f;
        color += float(MAXITER-i)/(f2+.001);
    }
    vec3 color3 = vec3(0.5-1./(1.+color*(.09/float(MAXITER*MAXITER))));
    color3 *= color3;
    gl_FragColor = vec4(color3.r*R_FACTOR, color3.g*G_FACTOR, color3.b*B_FACTOR,1.);
}
</script>

<script>
// WebGL Setup
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
}
window.addEventListener('resize', resize);
resize();

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }
    return shader;
}

const vertexShaderSource = `
attribute vec4 position;
void main() {
    gl_Position = position;
}`;
const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);

const fragmentShaderSource = document.getElementById("fragShader").textContent;
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

gl.useProgram(program);

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1, 1, -1, -1, 1,
    -1, 1, 1, -1, 1, 1,
]), gl.STATIC_DRAW);

const positionLocation = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

const resolutionLocation = gl.getUniformLocation(program, "resolution");
const timeLocation = gl.getUniformLocation(program, "time");

function render(time) {
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    gl.uniform1f(timeLocation, time * 0.001);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>

</body>
</html>
